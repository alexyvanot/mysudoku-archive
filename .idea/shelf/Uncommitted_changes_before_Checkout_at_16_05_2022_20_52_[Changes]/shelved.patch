Index: pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <groupId>com.intech</groupId>\r\n    <artifactId>mysudoku</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <properties>\r\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n        <maven.compiler.source>11</maven.compiler.source>\r\n        <maven.compiler.target>11</maven.compiler.target>\r\n    </properties>\r\n    <dependencies>\r\n    \t<dependency>\r\n            <groupId>org.openjfx</groupId>\r\n            <artifactId>javafx-graphics</artifactId>\r\n            <version>13</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.openjfx</groupId>\r\n            <artifactId>javafx-controls</artifactId>\r\n            <version>13</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.openjfx</groupId>\r\n            <artifactId>javafx-fxml</artifactId>\r\n            <version>13</version>\r\n        </dependency>\r\n    </dependencies>\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-compiler-plugin</artifactId>\r\n                <version>3.8.0</version>\r\n                <configuration>\r\n                    <release>11</release>\r\n                </configuration>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.openjfx</groupId>\r\n                <artifactId>javafx-maven-plugin</artifactId>\r\n                <version>0.0.6</version>\r\n                <executions>\r\n                    <execution>\r\n                        <!-- Default configuration for running -->\r\n                        <!-- Usage: mvn clean javafx:run -->\r\n                        <id>default-cli</id>\r\n                        <configuration>\r\n                            <mainClass>com.intech.mysudoku.application.MySudokuApp</mainClass>\r\n                        </configuration>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n</project>\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pom.xml b/pom.xml
--- a/pom.xml	
+++ b/pom.xml	
@@ -13,44 +13,89 @@
     	<dependency>
             <groupId>org.openjfx</groupId>
             <artifactId>javafx-graphics</artifactId>
-            <version>13</version>
+            <version>11</version>
         </dependency>
         <dependency>
             <groupId>org.openjfx</groupId>
             <artifactId>javafx-controls</artifactId>
-            <version>13</version>
+            <version>11</version>
         </dependency>
         <dependency>
             <groupId>org.openjfx</groupId>
             <artifactId>javafx-fxml</artifactId>
-            <version>13</version>
+            <version>11</version>
         </dependency>
     </dependencies>
     <build>
+
         <plugins>
             <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.8.0</version>
+                <version>3.8.1</version>
                 <configuration>
                     <release>11</release>
                 </configuration>
             </plugin>
+
             <plugin>
                 <groupId>org.openjfx</groupId>
                 <artifactId>javafx-maven-plugin</artifactId>
-                <version>0.0.6</version>
-                <executions>
-                    <execution>
-                        <!-- Default configuration for running -->
-                        <!-- Usage: mvn clean javafx:run -->
-                        <id>default-cli</id>
-                        <configuration>
+                <version>0.0.1</version>
+                <configuration>
+                    <mainClass>com.intech.mysudoku.application.MySudokuApp</mainClass>
+                </configuration>
+            </plugin>
+
+
+            <plugin>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <version>2.22.2</version>
+            </plugin>
+
+            <plugin>
+                <artifactId>maven-assembly-plugin</artifactId>
+                <configuration>
+                    <archive>
+                        <manifest>
                             <mainClass>com.intech.mysudoku.application.MySudokuApp</mainClass>
-                        </configuration>
+                        </manifest>
+                    </archive>
+                    <descriptorRefs>
+                        <descriptorRef>jar-with-dependencies</descriptorRef>
+                    </descriptorRefs>
+                </configuration>
+                <executions>
+                    <execution>
+                        <id>make-assembly</id>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>single</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+
+            <plugin>
+                <groupId>org.jacoco</groupId>
+                <artifactId>jacoco-maven-plugin</artifactId>
+                <version>0.8.5</version>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>prepare-agent</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>report</id>
+                        <phase>test</phase>
+                        <goals>
+                            <goal>report</goal>
+                        </goals>
                     </execution>
                 </executions>
             </plugin>
+
         </plugins>
+
     </build>
 </project>
Index: src/main/java/com/intech/mysudoku/controllers/SettingsScreenController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.controllers;\r\n\r\nimport javafx.fxml.FXML;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.ChoiceBox;\r\nimport javafx.scene.control.Slider;\r\nimport javafx.scene.layout.AnchorPane;\r\n\r\nimport java.awt.*;\r\nimport java.net.URL;\r\nimport java.util.ResourceBundle;\r\n\r\npublic class SettingsScreenController {\r\n\r\n    private Scene scene;\r\n    private TitleScreenController titleScreenController;\r\n\r\n    @FXML\r\n    AnchorPane anchorPane;\r\n    @FXML\r\n    Label titleLabel;\r\n    @FXML\r\n    Label soundsLabel;\r\n    @FXML\r\n    Label musicLabel;\r\n    @FXML\r\n    Checkbox musicCheckBox;\r\n    @FXML\r\n    Label volumeLabel;\r\n    @FXML\r\n    Slider volumeSlider;\r\n    @FXML\r\n    Label languageLabel;\r\n    @FXML\r\n    Label selectedLanguageLabel;\r\n    @FXML\r\n    ChoiceBox languageChoiceBox;\r\n    @FXML\r\n    Label guiLabel;\r\n    @FXML\r\n    Label colorAssistanceLabel;\r\n    @FXML\r\n    Checkbox colorAssistanceCheckBox;\r\n\r\n    public void setTitleScreenController (TitleScreenController titleScreenController) {\r\n        this.titleScreenController = titleScreenController;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/controllers/SettingsScreenController.java b/src/main/java/com/intech/mysudoku/controllers/SettingsScreenController.java
--- a/src/main/java/com/intech/mysudoku/controllers/SettingsScreenController.java	
+++ b/src/main/java/com/intech/mysudoku/controllers/SettingsScreenController.java	
@@ -1,49 +1,13 @@
 package com.intech.mysudoku.controllers;
 
-import javafx.fxml.FXML;
-import javafx.scene.Scene;
-import javafx.scene.control.ChoiceBox;
-import javafx.scene.control.Slider;
-import javafx.scene.layout.AnchorPane;
+import javafx.fxml.Initializable;
 
-import java.awt.*;
 import java.net.URL;
 import java.util.ResourceBundle;
 
-public class SettingsScreenController {
-
-    private Scene scene;
-    private TitleScreenController titleScreenController;
-
-    @FXML
-    AnchorPane anchorPane;
-    @FXML
-    Label titleLabel;
-    @FXML
-    Label soundsLabel;
-    @FXML
-    Label musicLabel;
-    @FXML
-    Checkbox musicCheckBox;
-    @FXML
-    Label volumeLabel;
-    @FXML
-    Slider volumeSlider;
-    @FXML
-    Label languageLabel;
-    @FXML
-    Label selectedLanguageLabel;
-    @FXML
-    ChoiceBox languageChoiceBox;
-    @FXML
-    Label guiLabel;
-    @FXML
-    Label colorAssistanceLabel;
-    @FXML
-    Checkbox colorAssistanceCheckBox;
-
-    public void setTitleScreenController (TitleScreenController titleScreenController) {
-        this.titleScreenController = titleScreenController;
-    }
+public class SettingsScreenController implements Initializable {
+    @Override
+    public void initialize(URL location, ResourceBundle resources) {
 
-}
+    }
+}
\ No newline at end of file
Index: src/main/java/com/intech/mysudoku/application/MySudokuApp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.application;\r\n\r\nimport com.intech.mysudoku.controllers.TitleScreenController;\r\nimport com.intech.mysudoku.tools.Board;\r\nimport com.intech.mysudoku.tools.Creator;\r\nimport com.intech.mysudoku.tools.Level;\r\nimport com.intech.mysudoku.tools.Solver;\r\n\r\nimport javafx.application.Application;\r\nimport javafx.fxml.FXMLLoader;\r\nimport javafx.scene.Parent;\r\nimport javafx.scene.Scene;\r\nimport javafx.stage.Stage;\r\n\r\npublic class MySudokuApp extends Application {\r\n\r\n    @Override\r\n    public void start(Stage primaryStage) throws Exception {\r\n    \t\r\n    \t/**\r\n    \t * Sudoku invocator\r\n    \t */\r\n    \tSystem.out.println(\"Loading application...\");\r\n    \tCreator sudoku = new Creator();\r\n\t\tsudoku.create(Level.EASY);\r\n\t\tBoard sudokuBoard = sudoku.getBoard();\r\n\t\tSystem.out.println(sudokuBoard);\r\n\t\tSolver solveThisSukodu = new Solver();\r\n\t\tsolveThisSukodu.setBoard(sudokuBoard).solve(sudokuBoard.getCells(), 1);\r\n\t\tSystem.out.println();\r\n\t\tSystem.out.println(sudokuBoard);\r\n    \t\r\n    \t/* \"Deprecated\"\r\n    \tint N = 9, K = 20;\r\n\t\tSudoku sudoku = new Sudoku(N, K);\r\n\t\tsudoku.fillValues();\r\n\t\tsudoku.printSudoku(); // Show in console \r\n\t\t*/\r\n\t\t\r\n        try {\r\n            FXMLLoader loader = new FXMLLoader(getClass().getClassLoader().getResource(\"views/titleScreen.fxml\"));\r\n            Parent root = loader.load();\r\n            TitleScreenController titleScreenController = loader.getController();\r\n            Scene scene = new Scene(root);\r\n            titleScreenController.setStartScene(scene);\r\n            primaryStage.setScene(scene);\r\n            primaryStage.show();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/application/MySudokuApp.java b/src/main/java/com/intech/mysudoku/application/MySudokuApp.java
--- a/src/main/java/com/intech/mysudoku/application/MySudokuApp.java	
+++ b/src/main/java/com/intech/mysudoku/application/MySudokuApp.java	
@@ -1,42 +1,15 @@
 package com.intech.mysudoku.application;
 
-import com.intech.mysudoku.controllers.TitleScreenController;
-import com.intech.mysudoku.tools.Board;
-import com.intech.mysudoku.tools.Creator;
-import com.intech.mysudoku.tools.Level;
-import com.intech.mysudoku.tools.Solver;
-
 import javafx.application.Application;
 import javafx.fxml.FXMLLoader;
 import javafx.scene.Parent;
 import javafx.scene.Scene;
 import javafx.stage.Stage;
+import com.intech.mysudoku.controllers.TitleScreenController;
 
 public class MySudokuApp extends Application {
-
     @Override
     public void start(Stage primaryStage) throws Exception {
-    	
-    	/**
-    	 * Sudoku invocator
-    	 */
-    	System.out.println("Loading application...");
-    	Creator sudoku = new Creator();
-		sudoku.create(Level.EASY);
-		Board sudokuBoard = sudoku.getBoard();
-		System.out.println(sudokuBoard);
-		Solver solveThisSukodu = new Solver();
-		solveThisSukodu.setBoard(sudokuBoard).solve(sudokuBoard.getCells(), 1);
-		System.out.println();
-		System.out.println(sudokuBoard);
-    	
-    	/* "Deprecated"
-    	int N = 9, K = 20;
-		Sudoku sudoku = new Sudoku(N, K);
-		sudoku.fillValues();
-		sudoku.printSudoku(); // Show in console 
-		*/
-		
         try {
             FXMLLoader loader = new FXMLLoader(getClass().getClassLoader().getResource("views/titleScreen.fxml"));
             Parent root = loader.load();
@@ -49,7 +22,4 @@
             e.printStackTrace();
         }
     }
-
-
-
-}
+}
\ No newline at end of file
Index: src/main/java/com/intech/mysudoku/tools/Board.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.tools;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\n\r\n/**\r\n * Sudoku game board composed of Cell objects.\r\n */\r\npublic class Board implements Iterable<Cell>, Cloneable {\r\n\r\n    final private Cell[][] grid;\r\n    final private List<List<Cell>> blocks;\r\n    final private List<Cell> cells;\r\n    private Iteration iteration = Iteration.LINEAR;\r\n\r\n    public Board() {\r\n        grid = new Cell[9][9];\r\n        blocks = createBlocks(9);\r\n        cells = new ArrayList<Cell>(81);\r\n        createCells();\r\n    }\r\n\r\n    /**\r\n     * @return List of Cells objects of given game board.\r\n     */\r\n    public List<Cell> getCells() {\r\n        return cells;\r\n    }\r\n\r\n    /**\r\n     * @return List of Lists of Cells, which are grouping Cells by it position within board blocks.\r\n     */\r\n    public List<List<Cell>> getBlocks() { return blocks; }\r\n\r\n    /**\r\n     * Set type of iteration through Boards cells. It use Iteration enum class objects.\r\n     * @param order Iteration enum type object assigned to given iteration type.\r\n     */\r\n    public void setIterationOrder(Iteration order) {\r\n        iteration = order;\r\n    }\r\n\r\n    /**\r\n     * Creates 2D array of Cells object, which make game board.\r\n     */\r\n    public void createCells() {\r\n        for(int row = 0; row < 9; row++) {\r\n            for(int col = 0; col < 9; col++) {\r\n                Cell cell = new Cell(row,col);\r\n                grid[row][col] = cell;\r\n                cells.add(cell);\r\n                blocks.get(cell.getBlock()).add(cell);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * It tests all three game conditions for particular Cell and value.\r\n     * @param cell given Cell.\r\n     * @param value which wil be assigned to Cell if it fulfills all conditions.\r\n     * @return true if value in given Cell fulfills all three game conditions.\r\n     */\r\n    public boolean testConditions(Cell cell, int value) {\r\n        return testBlock(cell, value) && testColumn(cell.getColumn(), value) && testRow(cell.getRow(), value);\r\n    }\r\n\r\n    /**\r\n     * It tests if given value is unique in given game board row.\r\n     * @param row checked row.\r\n     * @param value tested value.\r\n     * @return true if value is unique in given row.\r\n     */\r\n    private boolean testRow(int row, int value) {\r\n        for(Cell cell : grid[row]) {\r\n            if(value == cell.getValue()) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * It tests if given value is unique in given game board column.\r\n     * @param column checked column.\r\n     * @param value tested value.\r\n     * @return true if value is unique in given column.\r\n     */\r\n    private boolean testColumn(int column, int value) {\r\n        for(Cell[] cells : grid) {\r\n            if(value == cells[column].getValue()) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * It tests if given value is unique in given game board block (3 x 3 Cells group).\r\n     * @param testedCell tested Cell.\r\n     * @param value tested value.\r\n     * @return true if value is unique in given block.\r\n     */\r\n    private boolean testBlock(Cell testedCell, int value) {\r\n        for(Cell cell : blocks.get(testedCell.getBlock())) {\r\n            if(cell.getValue() == value) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Calls save() method on every Cell within Board.\r\n     */\r\n    public void save() {\r\n        for(Cell cell : this) {\r\n            cell.save();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calls load() method on every Cell within Board.\r\n     */\r\n    public void load() {\r\n        for (Cell cell : this) {\r\n            cell.load();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return ListIterator of random order List of all Cells of a given Board.\r\n     */\r\n    private ListIterator<Cell> randomOrderIterator() {\r\n        ArrayList<Cell> randomOrder = new ArrayList<Cell>(cells);\r\n        Collections.shuffle(randomOrder);\r\n        return randomOrder.listIterator();\r\n    }\r\n\r\n    /**\r\n     * @return ListIterator of sequential order List of all Cells of a given Board.\r\n     */\r\n    private ListIterator<Cell> linearOrderIterator() {\r\n        return cells.listIterator();\r\n    }\r\n\r\n    /**\r\n     * @return ListIterator of S-like order List of all Cells of a given Board.\r\n     */\r\n    private ListIterator<Cell> sLikeOrderIterator() {\r\n        return s_LikeList().listIterator();\r\n    }\r\n\r\n    /**\r\n     * @return ListIterator object of given Board object with set iteration order.\r\n     */\r\n    @Override\r\n    public ListIterator<Cell> iterator() {\r\n        switch (iteration) {\r\n            case LINEAR:\r\n                return linearOrderIterator();\r\n            case RANDOM:\r\n                return randomOrderIterator();\r\n            case S_LIKE:\r\n                return sLikeOrderIterator();\r\n            default:\r\n                return linearOrderIterator();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return String contains all values of Cells within given Board.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        String result = \"\";\r\n        for(int i = 0; i < 9; i++) {\r\n            for(int j = 0; j < 9; j++) {\r\n                result += grid[i][j].toString() + \",\";\r\n            }\r\n            result += \"\\n\";\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the List of Lists of Cells of given Board.\r\n     * @param capacity number of Cells in given Sudoku game board.\r\n     * @return List of Lists of Cells assigned to specific blocks.\r\n     */\r\n    public List<List<Cell>> createBlocks(int capacity) {\r\n        List<List<Cell>> list = new ArrayList<List<Cell>>(capacity);\r\n        for(int i = 0; i < capacity; i++) {\r\n            list.add(new ArrayList<Cell>());\r\n        }\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Using a 2D Cell array containing all Cell objects of given Sudoku game board, this method crates List of\r\n     * same elements with changed order, which allows to iterate through Sudoku game board in S-like order.\r\n     * @return List of Cells of given game board with changed order.\r\n     */\r\n    public List<Cell> s_LikeList() {\r\n        List<Cell> sShape = new ArrayList<Cell>();\r\n        List<Cell> temp;\r\n        for(int i = 0; i < 9; i++) {\r\n            if((i+1)%2==0) {\r\n                temp = new ArrayList<Cell>(Arrays.asList(grid[i]));\r\n                Collections.reverse(temp);\r\n                sShape.addAll(temp);\r\n            } else {\r\n                sShape.addAll(Arrays.asList(grid[i]));\r\n            }\r\n        }\r\n        return sShape;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/tools/Board.java b/src/main/java/com/intech/mysudoku/tools/Board.java
--- a/src/main/java/com/intech/mysudoku/tools/Board.java	
+++ b/src/main/java/com/intech/mysudoku/tools/Board.java	
@@ -1,217 +1,0 @@
-package com.intech.mysudoku.tools;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.ListIterator;
-
-/**
- * Sudoku game board composed of Cell objects.
- */
-public class Board implements Iterable<Cell>, Cloneable {
-
-    final private Cell[][] grid;
-    final private List<List<Cell>> blocks;
-    final private List<Cell> cells;
-    private Iteration iteration = Iteration.LINEAR;
-
-    public Board() {
-        grid = new Cell[9][9];
-        blocks = createBlocks(9);
-        cells = new ArrayList<Cell>(81);
-        createCells();
-    }
-
-    /**
-     * @return List of Cells objects of given game board.
-     */
-    public List<Cell> getCells() {
-        return cells;
-    }
-
-    /**
-     * @return List of Lists of Cells, which are grouping Cells by it position within board blocks.
-     */
-    public List<List<Cell>> getBlocks() { return blocks; }
-
-    /**
-     * Set type of iteration through Boards cells. It use Iteration enum class objects.
-     * @param order Iteration enum type object assigned to given iteration type.
-     */
-    public void setIterationOrder(Iteration order) {
-        iteration = order;
-    }
-
-    /**
-     * Creates 2D array of Cells object, which make game board.
-     */
-    public void createCells() {
-        for(int row = 0; row < 9; row++) {
-            for(int col = 0; col < 9; col++) {
-                Cell cell = new Cell(row,col);
-                grid[row][col] = cell;
-                cells.add(cell);
-                blocks.get(cell.getBlock()).add(cell);
-            }
-        }
-    }
-
-    /**
-     * It tests all three game conditions for particular Cell and value.
-     * @param cell given Cell.
-     * @param value which wil be assigned to Cell if it fulfills all conditions.
-     * @return true if value in given Cell fulfills all three game conditions.
-     */
-    public boolean testConditions(Cell cell, int value) {
-        return testBlock(cell, value) && testColumn(cell.getColumn(), value) && testRow(cell.getRow(), value);
-    }
-
-    /**
-     * It tests if given value is unique in given game board row.
-     * @param row checked row.
-     * @param value tested value.
-     * @return true if value is unique in given row.
-     */
-    private boolean testRow(int row, int value) {
-        for(Cell cell : grid[row]) {
-            if(value == cell.getValue()) return false;
-        }
-        return true;
-    }
-
-    /**
-     * It tests if given value is unique in given game board column.
-     * @param column checked column.
-     * @param value tested value.
-     * @return true if value is unique in given column.
-     */
-    private boolean testColumn(int column, int value) {
-        for(Cell[] cells : grid) {
-            if(value == cells[column].getValue()) return false;
-        }
-        return true;
-    }
-
-    /**
-     * It tests if given value is unique in given game board block (3 x 3 Cells group).
-     * @param testedCell tested Cell.
-     * @param value tested value.
-     * @return true if value is unique in given block.
-     */
-    private boolean testBlock(Cell testedCell, int value) {
-        for(Cell cell : blocks.get(testedCell.getBlock())) {
-            if(cell.getValue() == value) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Calls save() method on every Cell within Board.
-     */
-    public void save() {
-        for(Cell cell : this) {
-            cell.save();
-        }
-    }
-
-    /**
-     * Calls load() method on every Cell within Board.
-     */
-    public void load() {
-        for (Cell cell : this) {
-            cell.load();
-        }
-    }
-
-    /**
-     * @return ListIterator of random order List of all Cells of a given Board.
-     */
-    private ListIterator<Cell> randomOrderIterator() {
-        ArrayList<Cell> randomOrder = new ArrayList<Cell>(cells);
-        Collections.shuffle(randomOrder);
-        return randomOrder.listIterator();
-    }
-
-    /**
-     * @return ListIterator of sequential order List of all Cells of a given Board.
-     */
-    private ListIterator<Cell> linearOrderIterator() {
-        return cells.listIterator();
-    }
-
-    /**
-     * @return ListIterator of S-like order List of all Cells of a given Board.
-     */
-    private ListIterator<Cell> sLikeOrderIterator() {
-        return s_LikeList().listIterator();
-    }
-
-    /**
-     * @return ListIterator object of given Board object with set iteration order.
-     */
-    @Override
-    public ListIterator<Cell> iterator() {
-        switch (iteration) {
-            case LINEAR:
-                return linearOrderIterator();
-            case RANDOM:
-                return randomOrderIterator();
-            case S_LIKE:
-                return sLikeOrderIterator();
-            default:
-                return linearOrderIterator();
-        }
-    }
-
-    /**
-     * @return String contains all values of Cells within given Board.
-     */
-    @Override
-    public String toString() {
-        String result = "";
-        for(int i = 0; i < 9; i++) {
-            for(int j = 0; j < 9; j++) {
-                result += grid[i][j].toString() + ",";
-            }
-            result += "\n";
-        }
-        return result;
-    }
-
-    /**
-     * Creates the List of Lists of Cells of given Board.
-     * @param capacity number of Cells in given Sudoku game board.
-     * @return List of Lists of Cells assigned to specific blocks.
-     */
-    public List<List<Cell>> createBlocks(int capacity) {
-        List<List<Cell>> list = new ArrayList<List<Cell>>(capacity);
-        for(int i = 0; i < capacity; i++) {
-            list.add(new ArrayList<Cell>());
-        }
-        return list;
-    }
-
-    /**
-     * Using a 2D Cell array containing all Cell objects of given Sudoku game board, this method crates List of
-     * same elements with changed order, which allows to iterate through Sudoku game board in S-like order.
-     * @return List of Cells of given game board with changed order.
-     */
-    public List<Cell> s_LikeList() {
-        List<Cell> sShape = new ArrayList<Cell>();
-        List<Cell> temp;
-        for(int i = 0; i < 9; i++) {
-            if((i+1)%2==0) {
-                temp = new ArrayList<Cell>(Arrays.asList(grid[i]));
-                Collections.reverse(temp);
-                sShape.addAll(temp);
-            } else {
-                sShape.addAll(Arrays.asList(grid[i]));
-            }
-        }
-        return sShape;
-    }
-
-}
Index: src/main/java/com/intech/mysudoku/tools/Cell.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.tools;\r\n\r\n/**\r\n * The smallest separate Element of Sudoku game board, which holds a value from range 1-9 or is blank (value is 0).\r\n */\r\npublic class Cell {\r\n    final private int row;\r\n    final private int column;\r\n    final private int block;\r\n    private int value;\r\n    private int save;\r\n    private int solution;\r\n\r\n    public Cell(int row, int column) {\r\n        this.row = row;\r\n        this.column = column;\r\n        block = specifyBlock();\r\n    }\r\n\r\n    /**\r\n     * @return row in which given cell is placed on Sudoku board\r\n     */\r\n    public int getRow() {\r\n        return row;\r\n    }\r\n\r\n    /**\r\n     * @return column in which given cell is placed on Sudoku board\r\n     */\r\n    public int getColumn() {\r\n        return column;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param value which the given cell will hold.\r\n     */\r\n    public void setValue(int value) {\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * @return Value currently held by the given Cell object.\r\n     */\r\n    public int getValue() {\r\n        return  value;\r\n    }\r\n\r\n    /**\r\n     * @return a integer from range 1-9, which identify in which block of Sudoku game board the given Cell\r\n     * object is placed.\r\n     */\r\n    public int getBlock() {\r\n        return block;\r\n    }\r\n\r\n    /**\r\n     * Verifies if value of given Cell object is blank (equal to 0).\r\n     * @return true if value of Cell is 0.\r\n     */\r\n    public boolean isBlank() {\r\n        return value==0;\r\n    }\r\n\r\n    /**\r\n     * Saves the value of the given cell for future use. The value is saved until next usage of this method.\r\n     */\r\n    public void save() {\r\n        save = value;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the value saved by save() method. It does not affect the stored value.\r\n     */\r\n    public void load() {\r\n        value = save;\r\n    }\r\n\r\n    /**\r\n     * Save a value which is solution for given Cell in particular game board for future use.\r\n     */\r\n    public void setSolution() {\r\n        solution = value;\r\n    }\r\n\r\n    /**\r\n     * Retrieves saved value as solution.\r\n     * @return value which is solution for given Cell.\r\n     */\r\n    public int getSolution() {\r\n        return solution;\r\n    }\r\n    /**\r\n     * @return value currently held by the given cell.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return String.valueOf(getValue());\r\n    }\r\n\r\n    /**\r\n     * Compares two objects of Cell class.\r\n     * @param obj object to which given Cell object is compared.\r\n     * @return Returns true if both Cells have same value,  row and column field values, or false if compare\r\n     * Cell objects have different values or one or both objects are null.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        return obj != null && obj.getClass() == this.getClass() && ((Cell) obj).getValue() == this.getValue() &&\r\n                ((Cell) obj).getRow() == this.getRow() && ((Cell) obj).getColumn() == this.getColumn();\r\n    }\r\n\r\n    /**\r\n     * @return block of Sudoku game board, to which given Cell belongs.\r\n     */\r\n    public int specifyBlock() {\r\n        int x = row /3;\r\n        int y = column /3;\r\n        int modifier = row <3 ? 0 : row <6 ? 2 : 4;\r\n        return x+y+modifier;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/tools/Cell.java b/src/main/java/com/intech/mysudoku/tools/Cell.java
--- a/src/main/java/com/intech/mysudoku/tools/Cell.java	
+++ b/src/main/java/com/intech/mysudoku/tools/Cell.java	
@@ -1,122 +1,0 @@
-package com.intech.mysudoku.tools;
-
-/**
- * The smallest separate Element of Sudoku game board, which holds a value from range 1-9 or is blank (value is 0).
- */
-public class Cell {
-    final private int row;
-    final private int column;
-    final private int block;
-    private int value;
-    private int save;
-    private int solution;
-
-    public Cell(int row, int column) {
-        this.row = row;
-        this.column = column;
-        block = specifyBlock();
-    }
-
-    /**
-     * @return row in which given cell is placed on Sudoku board
-     */
-    public int getRow() {
-        return row;
-    }
-
-    /**
-     * @return column in which given cell is placed on Sudoku board
-     */
-    public int getColumn() {
-        return column;
-    }
-
-    /**
-     *
-     * @param value which the given cell will hold.
-     */
-    public void setValue(int value) {
-        this.value = value;
-    }
-
-    /**
-     * @return Value currently held by the given Cell object.
-     */
-    public int getValue() {
-        return  value;
-    }
-
-    /**
-     * @return a integer from range 1-9, which identify in which block of Sudoku game board the given Cell
-     * object is placed.
-     */
-    public int getBlock() {
-        return block;
-    }
-
-    /**
-     * Verifies if value of given Cell object is blank (equal to 0).
-     * @return true if value of Cell is 0.
-     */
-    public boolean isBlank() {
-        return value==0;
-    }
-
-    /**
-     * Saves the value of the given cell for future use. The value is saved until next usage of this method.
-     */
-    public void save() {
-        save = value;
-    }
-
-    /**
-     * Retrieves the value saved by save() method. It does not affect the stored value.
-     */
-    public void load() {
-        value = save;
-    }
-
-    /**
-     * Save a value which is solution for given Cell in particular game board for future use.
-     */
-    public void setSolution() {
-        solution = value;
-    }
-
-    /**
-     * Retrieves saved value as solution.
-     * @return value which is solution for given Cell.
-     */
-    public int getSolution() {
-        return solution;
-    }
-    /**
-     * @return value currently held by the given cell.
-     */
-    @Override
-    public String toString() {
-        return String.valueOf(getValue());
-    }
-
-    /**
-     * Compares two objects of Cell class.
-     * @param obj object to which given Cell object is compared.
-     * @return Returns true if both Cells have same value,  row and column field values, or false if compare
-     * Cell objects have different values or one or both objects are null.
-     */
-    @Override
-    public boolean equals(Object obj) {
-        return obj != null && obj.getClass() == this.getClass() && ((Cell) obj).getValue() == this.getValue() &&
-                ((Cell) obj).getRow() == this.getRow() && ((Cell) obj).getColumn() == this.getColumn();
-    }
-
-    /**
-     * @return block of Sudoku game board, to which given Cell belongs.
-     */
-    public int specifyBlock() {
-        int x = row /3;
-        int y = column /3;
-        int modifier = row <3 ? 0 : row <6 ? 2 : 4;
-        return x+y+modifier;
-    }
-}
Index: src/main/java/com/intech/mysudoku/model/SudokuGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.model;\r\n\r\npublic class SudokuGenerator {\r\n\r\n    int[] mat[];\r\n    int N; // number of columns/rows\r\n    int SRN; // square root of N\r\n    int K; // number of missing digits\r\n\r\n    /**\r\n     * Constructor\r\n     * @param N number of columns/rows\r\n     * @param K number of missing digits\r\n     */\r\n    public SudokuGenerator(int N, int K) {\r\n        this.N = N;\r\n        this.K = K;\r\n\r\n        // Compute square root of N\r\n        Double SRNd = Math.sqrt(N);\r\n        SRN = SRNd.intValue();\r\n\r\n        mat = new int[N][N];\r\n    }\r\n\r\n    /**\r\n     * Sudoku Generator\r\n     */\r\n    public void fillValues() {\r\n        // Fill the diagonal of SRN x SRN matrices\r\n        fillDiagonal();\r\n\r\n        // Fill remaining blocks\r\n        fillRemaining(0, SRN);\r\n\r\n        // Remove Randomly K digits to make game\r\n        removeKDigits();\r\n    }\r\n\r\n    /**\r\n     * Fill the diagonal SRN number of SRN x SRN matrices\r\n     */\r\n    void fillDiagonal() {\r\n\r\n        for (int i = 0; i<N; i=i+SRN)\r\n\r\n            // for diagonal box, start coordinates->i==j\r\n            fillBox(i, i);\r\n    }\r\n\r\n    /**\r\n     * Returns false if given 3 x 3 block contains num.\r\n     * @param rowStart\r\n     * @param colStart\r\n     * @param num\r\n     * @return boolean\r\n     */\r\n    boolean unUsedInBox(int rowStart, int colStart, int num) {\r\n        for (int i = 0; i<SRN; i++)\r\n            for (int j = 0; j<SRN; j++)\r\n                if (mat[rowStart+i][colStart+j]==num)\r\n                    return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Fill a 3 x 3 matrix.\r\n     * @param row\r\n     * @param col\r\n     */\r\n    void fillBox(int row,int col) {\r\n        int num;\r\n        for (int i=0; i<SRN; i++)\r\n        {\r\n            for (int j=0; j<SRN; j++)\r\n            {\r\n                do\r\n                {\r\n                    num = randomGenerator(N);\r\n                }\r\n                while (!unUsedInBox(row, col, num));\r\n\r\n                mat[row+i][col+j] = num;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random generator\r\n     * @param num\r\n     * @return int\r\n     */\r\n    int randomGenerator(int num) {\r\n        return (int) Math.floor((Math.random()*num+1));\r\n    }\r\n\r\n    /**\r\n     * Check if safe to put in cell\r\n     * @param i\r\n     * @param j\r\n     * @param num\r\n     * @return boolean\r\n     */\r\n    boolean CheckIfSafe(int i,int j,int num) {\r\n        return (unUsedInRow(i, num) &&\r\n                unUsedInCol(j, num) &&\r\n                unUsedInBox(i-i%SRN, j-j%SRN, num));\r\n    }\r\n\r\n    /**\r\n     * check in the row for existence\r\n     * @param i\r\n     * @param num\r\n     * @return boolean\r\n     */\r\n    boolean unUsedInRow(int i,int num) {\r\n        for (int j = 0; j<N; j++)\r\n            if (mat[i][j] == num)\r\n                return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * check in the row for existence\r\n     * @param j\r\n     * @param num\r\n     * @return boolean\r\n     */\r\n    boolean unUsedInCol(int j,int num) {\r\n        for (int i = 0; i<N; i++)\r\n            if (mat[i][j] == num)\r\n                return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  A recursive function to fill remaining\r\n     *  matrix\r\n     * @param i\r\n     * @param j\r\n     * @return boolean\r\n     */\r\n    boolean fillRemaining(int i, int j) {\r\n        //  System.out.println(i+\" \"+j);\r\n        if (j>=N && i<N-1) {\r\n            i = i + 1;\r\n            j = 0;\r\n        }\r\n        if (i>=N && j>=N)\r\n            return true;\r\n\r\n        if (i < SRN) {\r\n            if (j < SRN)\r\n                j = SRN;\r\n        } else if (i < N-SRN) {\r\n            if (j==(int)(i/SRN)*SRN)\r\n                j =  j + SRN;\r\n        } else {\r\n            if (j == N-SRN) {\r\n                i = i + 1;\r\n                j = 0;\r\n                if (i>=N)\r\n                    return true;\r\n            }\r\n        }\r\n\r\n        for (int num = 1; num<=N; num++) {\r\n            if (CheckIfSafe(i, j, num)) {\r\n                mat[i][j] = num;\r\n                if (fillRemaining(i, j+1))\r\n                    return true;\r\n\r\n                mat[i][j] = 0;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Remove the K numbers of digits to\r\n     * complete game\r\n     */\r\n    public void removeKDigits() {\r\n        int count = K;\r\n        while (count != 0) {\r\n            int cellId = randomGenerator(N*N)-1;\r\n\r\n            // System.out.println(cellId);\r\n            // extract coordinates i  and j\r\n            int i = (cellId/N);\r\n            int j = cellId%9;\r\n            if (j != 0)\r\n                j = j - 1;\r\n\r\n            // System.out.println(i+\" \"+j);\r\n            if (mat[i][j] != 0) {\r\n                count--;\r\n                mat[i][j] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Print sudoku\r\n     */\r\n    public void printSudoku() {\r\n        for (int i = 0; i<N; i++)\r\n        {\r\n            for (int j = 0; j<N; j++)\r\n                System.out.print(mat[i][j] + \" \");\r\n            System.out.println();\r\n        }\r\n        System.out.println();\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/model/SudokuGenerator.java b/src/main/java/com/intech/mysudoku/model/SudokuGenerator.java
--- a/src/main/java/com/intech/mysudoku/model/SudokuGenerator.java	
+++ b/src/main/java/com/intech/mysudoku/model/SudokuGenerator.java	
@@ -1,217 +1,0 @@
-package com.intech.mysudoku.model;
-
-public class SudokuGenerator {
-
-    int[] mat[];
-    int N; // number of columns/rows
-    int SRN; // square root of N
-    int K; // number of missing digits
-
-    /**
-     * Constructor
-     * @param N number of columns/rows
-     * @param K number of missing digits
-     */
-    public SudokuGenerator(int N, int K) {
-        this.N = N;
-        this.K = K;
-
-        // Compute square root of N
-        Double SRNd = Math.sqrt(N);
-        SRN = SRNd.intValue();
-
-        mat = new int[N][N];
-    }
-
-    /**
-     * Sudoku Generator
-     */
-    public void fillValues() {
-        // Fill the diagonal of SRN x SRN matrices
-        fillDiagonal();
-
-        // Fill remaining blocks
-        fillRemaining(0, SRN);
-
-        // Remove Randomly K digits to make game
-        removeKDigits();
-    }
-
-    /**
-     * Fill the diagonal SRN number of SRN x SRN matrices
-     */
-    void fillDiagonal() {
-
-        for (int i = 0; i<N; i=i+SRN)
-
-            // for diagonal box, start coordinates->i==j
-            fillBox(i, i);
-    }
-
-    /**
-     * Returns false if given 3 x 3 block contains num.
-     * @param rowStart
-     * @param colStart
-     * @param num
-     * @return boolean
-     */
-    boolean unUsedInBox(int rowStart, int colStart, int num) {
-        for (int i = 0; i<SRN; i++)
-            for (int j = 0; j<SRN; j++)
-                if (mat[rowStart+i][colStart+j]==num)
-                    return false;
-
-        return true;
-    }
-
-    /**
-     * Fill a 3 x 3 matrix.
-     * @param row
-     * @param col
-     */
-    void fillBox(int row,int col) {
-        int num;
-        for (int i=0; i<SRN; i++)
-        {
-            for (int j=0; j<SRN; j++)
-            {
-                do
-                {
-                    num = randomGenerator(N);
-                }
-                while (!unUsedInBox(row, col, num));
-
-                mat[row+i][col+j] = num;
-            }
-        }
-    }
-
-    /**
-     * Random generator
-     * @param num
-     * @return int
-     */
-    int randomGenerator(int num) {
-        return (int) Math.floor((Math.random()*num+1));
-    }
-
-    /**
-     * Check if safe to put in cell
-     * @param i
-     * @param j
-     * @param num
-     * @return boolean
-     */
-    boolean CheckIfSafe(int i,int j,int num) {
-        return (unUsedInRow(i, num) &&
-                unUsedInCol(j, num) &&
-                unUsedInBox(i-i%SRN, j-j%SRN, num));
-    }
-
-    /**
-     * check in the row for existence
-     * @param i
-     * @param num
-     * @return boolean
-     */
-    boolean unUsedInRow(int i,int num) {
-        for (int j = 0; j<N; j++)
-            if (mat[i][j] == num)
-                return false;
-        return true;
-    }
-
-    /**
-     * check in the row for existence
-     * @param j
-     * @param num
-     * @return boolean
-     */
-    boolean unUsedInCol(int j,int num) {
-        for (int i = 0; i<N; i++)
-            if (mat[i][j] == num)
-                return false;
-        return true;
-    }
-
-    /**
-     *  A recursive function to fill remaining
-     *  matrix
-     * @param i
-     * @param j
-     * @return boolean
-     */
-    boolean fillRemaining(int i, int j) {
-        //  System.out.println(i+" "+j);
-        if (j>=N && i<N-1) {
-            i = i + 1;
-            j = 0;
-        }
-        if (i>=N && j>=N)
-            return true;
-
-        if (i < SRN) {
-            if (j < SRN)
-                j = SRN;
-        } else if (i < N-SRN) {
-            if (j==(int)(i/SRN)*SRN)
-                j =  j + SRN;
-        } else {
-            if (j == N-SRN) {
-                i = i + 1;
-                j = 0;
-                if (i>=N)
-                    return true;
-            }
-        }
-
-        for (int num = 1; num<=N; num++) {
-            if (CheckIfSafe(i, j, num)) {
-                mat[i][j] = num;
-                if (fillRemaining(i, j+1))
-                    return true;
-
-                mat[i][j] = 0;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Remove the K numbers of digits to
-     * complete game
-     */
-    public void removeKDigits() {
-        int count = K;
-        while (count != 0) {
-            int cellId = randomGenerator(N*N)-1;
-
-            // System.out.println(cellId);
-            // extract coordinates i  and j
-            int i = (cellId/N);
-            int j = cellId%9;
-            if (j != 0)
-                j = j - 1;
-
-            // System.out.println(i+" "+j);
-            if (mat[i][j] != 0) {
-                count--;
-                mat[i][j] = 0;
-            }
-        }
-    }
-
-    /**
-     * Print sudoku
-     */
-    public void printSudoku() {
-        for (int i = 0; i<N; i++)
-        {
-            for (int j = 0; j<N; j++)
-                System.out.print(mat[i][j] + " ");
-            System.out.println();
-        }
-        System.out.println();
-    }
-
-}
Index: src/main/java/com/intech/mysudoku/tools/Level.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.tools;\r\n\r\nimport java.util.Random;\r\n\r\n/**\r\n * Enum class for difficulty levels. Its min and max fields set a range, from which the number of blank cells\r\n * is randomly selected.\r\n */\r\npublic enum Level {\r\n\r\n    VERY_EASY(28,30,Iteration.RANDOM),\r\n    EASY(31,44,Iteration.RANDOM),\r\n    MODERATE(45,49,Iteration.S_LIKE),\r\n    HARD(49,54,Iteration.S_LIKE),\r\n    VERY_HARD(55,61,Iteration.LINEAR);\r\n\r\n    private final int min;\r\n    private final int max;\r\n    private final Iteration iterationType;\r\n\r\n    Level(int min, int max, Iteration iterationType) {\r\n        this.min = min;\r\n        this.max = max;\r\n        this.iterationType = iterationType;\r\n    }\r\n\r\n    /**\r\n     * It causes a differentiation of number of blank cells in game boards on the same difficulty level,\r\n     * in separate games.\r\n     * @return random number from range from minimal to maximal number of blank cells for given difficulty level.\r\n     */\r\n    public int getBlankCellsNumber() {\r\n        return new Random().nextInt((max - min) + 1) + min;\r\n    }\r\n\r\n    /**\r\n     * @return a iteration type used in creation of game boards on given difficulty level.\r\n     */\r\n    public Iteration getIterationType() {\r\n        return iterationType;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/tools/Level.java b/src/main/java/com/intech/mysudoku/tools/Level.java
--- a/src/main/java/com/intech/mysudoku/tools/Level.java	
+++ b/src/main/java/com/intech/mysudoku/tools/Level.java	
@@ -1,42 +1,0 @@
-package com.intech.mysudoku.tools;
-
-import java.util.Random;
-
-/**
- * Enum class for difficulty levels. Its min and max fields set a range, from which the number of blank cells
- * is randomly selected.
- */
-public enum Level {
-
-    VERY_EASY(28,30,Iteration.RANDOM),
-    EASY(31,44,Iteration.RANDOM),
-    MODERATE(45,49,Iteration.S_LIKE),
-    HARD(49,54,Iteration.S_LIKE),
-    VERY_HARD(55,61,Iteration.LINEAR);
-
-    private final int min;
-    private final int max;
-    private final Iteration iterationType;
-
-    Level(int min, int max, Iteration iterationType) {
-        this.min = min;
-        this.max = max;
-        this.iterationType = iterationType;
-    }
-
-    /**
-     * It causes a differentiation of number of blank cells in game boards on the same difficulty level,
-     * in separate games.
-     * @return random number from range from minimal to maximal number of blank cells for given difficulty level.
-     */
-    public int getBlankCellsNumber() {
-        return new Random().nextInt((max - min) + 1) + min;
-    }
-
-    /**
-     * @return a iteration type used in creation of game boards on given difficulty level.
-     */
-    public Iteration getIterationType() {
-        return iterationType;
-    }
-}
Index: src/main/java/com/intech/mysudoku/tools/Solver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.tools;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n/**\r\n * Solver object solves a given Sudoku board. It is used in stage of filling an empty Sudoku board with digits,\r\n * in verifying the uniqueness of solution and in checking a solution given by User.\r\n */\r\npublic class Solver {\r\n    private Board board;\r\n    private int count = 0;\r\n    int index = 0;\r\n\r\n    public Solver setBoard(Board board) {\r\n        this.board = board;\r\n        count = 0;\r\n        index = 0;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Recursive and backtracking method, which fills up the empty or partially solved Sudoku game board. It puts\r\n     * a digit into the blank Cell objects, if it pass the game conditions. If there is no such value, it backtrace\r\n     * to the last filled Cell object, which value could be changed. In effect it creates or solves a Sudoku puzzle.\r\n     * @param blankCells List of blank Cell objects from given Sudoku game board.\r\n     * @param limit randomly selected number of blank Cells the Sudoku board on given difficulty level could have.\r\n     * @return the number of found solutions.\r\n     */\r\n    public int solve(List<Cell> blankCells, int limit) {\r\n        if(index < blankCells.size()){\r\n            for(int i : randomOrderDigits()){\r\n                if(testValue(blankCells.get(index), i)) {\r\n                    index += 1;\r\n                    if(solve(blankCells, limit)>= limit) {\r\n                        return count;\r\n                    }\r\n                }\r\n            }\r\n            return backtrace(blankCells);\r\n        } else {\r\n            return finish();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Part of solve() method responsible for decrease of specified variables, what effects in backtracking during the\r\n     * solve() method execution. It returns a same value as the salve() method, because if there is no more solutions\r\n     * for given game board, and therefore solve() method would be terminated, it still returns counted number of\r\n     * found solutions.\r\n     * @param cells List of blank Cell objects from given Sudoku game board.\r\n     * @return the number of found solution.\r\n     */\r\n    private int backtrace(List<Cell> cells) {\r\n        cells.get(index).setValue(0);\r\n        index -= 1;\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Increases the value of variable which holds the number of found solutions, and begin a backtracking process,\r\n     * after the solve() method reaches a valid solution for the given game board. It returns a same value as the\r\n     * salve() method, because if there is no more solutions for given game board, and therefore solve() method would\r\n     * be terminated, it still returns counted number of found solutions.\r\n     * @return the number of found solution.\r\n     */\r\n    public int finish() {\r\n        count++;\r\n        index -= 1;\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Tests the game conditions for a given Cell object and value.\r\n     * @param cell the tested Cell object.\r\n     * @param i value which could be potentially placed in the given Cell object.\r\n     * @return true if the Call with the given value fulfill the game conditions.\r\n     */\r\n    private boolean testValue(Cell cell, int i) {\r\n        if (!board.testConditions(cell, i)) {\r\n            return false;\r\n        } else{\r\n            cell.setValue(i);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return return a List containing a digits (without 0) in random order.\r\n     */\r\n    public List<Integer> randomOrderDigits() {\r\n        List<Integer> values = new ArrayList<Integer>();\r\n        for(int i = 1; i <= 9; i++) {\r\n            values.add(i);\r\n        }\r\n        Collections.shuffle(values);\r\n        return values;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/tools/Solver.java b/src/main/java/com/intech/mysudoku/tools/Solver.java
--- a/src/main/java/com/intech/mysudoku/tools/Solver.java	
+++ b/src/main/java/com/intech/mysudoku/tools/Solver.java	
@@ -1,100 +1,0 @@
-package com.intech.mysudoku.tools;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Solver object solves a given Sudoku board. It is used in stage of filling an empty Sudoku board with digits,
- * in verifying the uniqueness of solution and in checking a solution given by User.
- */
-public class Solver {
-    private Board board;
-    private int count = 0;
-    int index = 0;
-
-    public Solver setBoard(Board board) {
-        this.board = board;
-        count = 0;
-        index = 0;
-        return this;
-    }
-
-    /**
-     * Recursive and backtracking method, which fills up the empty or partially solved Sudoku game board. It puts
-     * a digit into the blank Cell objects, if it pass the game conditions. If there is no such value, it backtrace
-     * to the last filled Cell object, which value could be changed. In effect it creates or solves a Sudoku puzzle.
-     * @param blankCells List of blank Cell objects from given Sudoku game board.
-     * @param limit randomly selected number of blank Cells the Sudoku board on given difficulty level could have.
-     * @return the number of found solutions.
-     */
-    public int solve(List<Cell> blankCells, int limit) {
-        if(index < blankCells.size()){
-            for(int i : randomOrderDigits()){
-                if(testValue(blankCells.get(index), i)) {
-                    index += 1;
-                    if(solve(blankCells, limit)>= limit) {
-                        return count;
-                    }
-                }
-            }
-            return backtrace(blankCells);
-        } else {
-            return finish();
-        }
-    }
-
-    /**
-     * Part of solve() method responsible for decrease of specified variables, what effects in backtracking during the
-     * solve() method execution. It returns a same value as the salve() method, because if there is no more solutions
-     * for given game board, and therefore solve() method would be terminated, it still returns counted number of
-     * found solutions.
-     * @param cells List of blank Cell objects from given Sudoku game board.
-     * @return the number of found solution.
-     */
-    private int backtrace(List<Cell> cells) {
-        cells.get(index).setValue(0);
-        index -= 1;
-        return count;
-    }
-
-    /**
-     * Increases the value of variable which holds the number of found solutions, and begin a backtracking process,
-     * after the solve() method reaches a valid solution for the given game board. It returns a same value as the
-     * salve() method, because if there is no more solutions for given game board, and therefore solve() method would
-     * be terminated, it still returns counted number of found solutions.
-     * @return the number of found solution.
-     */
-    public int finish() {
-        count++;
-        index -= 1;
-        return count;
-    }
-
-    /**
-     * Tests the game conditions for a given Cell object and value.
-     * @param cell the tested Cell object.
-     * @param i value which could be potentially placed in the given Cell object.
-     * @return true if the Call with the given value fulfill the game conditions.
-     */
-    private boolean testValue(Cell cell, int i) {
-        if (!board.testConditions(cell, i)) {
-            return false;
-        } else{
-            cell.setValue(i);
-            return true;
-        }
-    }
-
-    /**
-     * @return return a List containing a digits (without 0) in random order.
-     */
-    public List<Integer> randomOrderDigits() {
-        List<Integer> values = new ArrayList<Integer>();
-        for(int i = 1; i <= 9; i++) {
-            values.add(i);
-        }
-        Collections.shuffle(values);
-        return values;
-    }
-}
Index: src/main/java/com/intech/mysudoku/tools/Creator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.tools;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\n\r\n/**\r\n * Creates a Sudoku game board according to given parameters.\r\n */\r\npublic class Creator {\r\n    private Solver solver;\r\n    private Board board;\r\n    private List<Cell> blankCells;\r\n    private int limit;\r\n\r\n    public Creator() {\r\n        solver = new Solver();\r\n    }\r\n\r\n    public Board create(Level level) {\r\n        board = new Board();\r\n        getFullBoard();\r\n        saveSolution();\r\n        randomizeBlankCellPositions(level);\r\n        generateBlankCells(level.getBlankCellsNumber(), level.getIterationType());\r\n        board.save();\r\n        return board;\r\n    }\r\n\r\n    /**\r\n     * @return a value of limit for blank cells for given Sudoku board.\r\n     */\r\n    public int getLimit() {\r\n        return limit;\r\n    }\r\n\r\n    /**\r\n     * @return Board object recently created by Creator.\r\n     */\r\n    public Board getBoard() {\r\n        return board;\r\n    }\r\n\r\n    /**\r\n     * Generates game board full of numbers.\r\n     */\r\n    private void getFullBoard() {\r\n        solver.setBoard(board).solve(board.getCells(), 1);\r\n    }\r\n\r\n\r\n    /**\r\n     * Iterates through all Cell of given board, and call setSolution() method, to save solution for future comparing\r\n     * to user input.\r\n     */\r\n    private void saveSolution() {\r\n        for(Cell cell : board){\r\n            cell.setSolution();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * It is used before generateBlankCells() method in cases when S-like iteration type is used with number of blank\r\n     * Cells lower or near the half of Cells number. This prevents the game board to be unevenly distributed on board.\r\n     * @param level which determines iteration type.\r\n     */\r\n    private void randomizeBlankCellPositions(Level level) {\r\n        if(level.equals(Level.MODERATE) || level.equals(Level.HARD)) {\r\n            generateBlankCells(30, Iteration.RANDOM);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a blank Cells in full Sudoku game board.\r\n     * @param limit number of blank cells given puzzle should have.\r\n     * @param iteration used iteration type through Boards cells.\r\n     */\r\n    public void generateBlankCells(int limit, Iteration iteration) {\r\n        this.limit = limit;\r\n        board.setIterationOrder(iteration);\r\n        ListIterator<Cell> iterator = board.iterator();\r\n        board.save();\r\n\r\n        while (iterator.hasNext()) {\r\n            Cell current = iterator.next();\r\n            current.save();\r\n\r\n\r\n            if (!current.isBlank()) {\r\n                current.setValue(0);\r\n            } else {\r\n                continue;\r\n            }\r\n\r\n            solver.setBoard(board);\r\n            blankCells = getBlankCells(board);\r\n            if(isOutOfLimits(limit)) {\r\n                break;\r\n            }\r\n\r\n            if (hasMoreThanOneSolution(blankCells)) {\r\n                board.load();\r\n            } else {\r\n                current.save();\r\n            }\r\n        }\r\n        board.setIterationOrder(Iteration.LINEAR);\r\n    }\r\n\r\n    /**\r\n     * Determines when there is too many number of solution for given type of task.\r\n     * @param limit restraining value.\r\n     * @return true if there is more or equal number of blank Cells in caparison to demanded fo given difficulty level,\r\n     */\r\n    public boolean isOutOfLimits(int limit) {\r\n        return blankCells.size() >= limit;\r\n    }\r\n\r\n    /**\r\n     * @param blanks List of blank Cells, which combination with hint numbers, is tested for solution uniqueness.\r\n     * @return true if given set of values has one solution.\r\n     */\r\n    private boolean hasMoreThanOneSolution(List<Cell> blanks) {\r\n        return solver.solve(blanks, 3) != 1;\r\n    }\r\n\r\n    /**\r\n     * @param board Sudoku game board.\r\n     * @return List of blank Cells in given Board.\r\n     */\r\n    public static List<Cell> getBlankCells(Board board) {\r\n        List<Cell> blank = new ArrayList<Cell>();\r\n        for(Cell cell : board) {\r\n            if(cell.isBlank()) {\r\n                blank.add(cell);\r\n            }\r\n        }\r\n        return blank;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/tools/Creator.java b/src/main/java/com/intech/mysudoku/tools/Creator.java
--- a/src/main/java/com/intech/mysudoku/tools/Creator.java	
+++ b/src/main/java/com/intech/mysudoku/tools/Creator.java	
@@ -1,140 +1,0 @@
-package com.intech.mysudoku.tools;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.ListIterator;
-
-/**
- * Creates a Sudoku game board according to given parameters.
- */
-public class Creator {
-    private Solver solver;
-    private Board board;
-    private List<Cell> blankCells;
-    private int limit;
-
-    public Creator() {
-        solver = new Solver();
-    }
-
-    public Board create(Level level) {
-        board = new Board();
-        getFullBoard();
-        saveSolution();
-        randomizeBlankCellPositions(level);
-        generateBlankCells(level.getBlankCellsNumber(), level.getIterationType());
-        board.save();
-        return board;
-    }
-
-    /**
-     * @return a value of limit for blank cells for given Sudoku board.
-     */
-    public int getLimit() {
-        return limit;
-    }
-
-    /**
-     * @return Board object recently created by Creator.
-     */
-    public Board getBoard() {
-        return board;
-    }
-
-    /**
-     * Generates game board full of numbers.
-     */
-    private void getFullBoard() {
-        solver.setBoard(board).solve(board.getCells(), 1);
-    }
-
-
-    /**
-     * Iterates through all Cell of given board, and call setSolution() method, to save solution for future comparing
-     * to user input.
-     */
-    private void saveSolution() {
-        for(Cell cell : board){
-            cell.setSolution();
-        }
-    }
-
-    /**
-     * It is used before generateBlankCells() method in cases when S-like iteration type is used with number of blank
-     * Cells lower or near the half of Cells number. This prevents the game board to be unevenly distributed on board.
-     * @param level which determines iteration type.
-     */
-    private void randomizeBlankCellPositions(Level level) {
-        if(level.equals(Level.MODERATE) || level.equals(Level.HARD)) {
-            generateBlankCells(30, Iteration.RANDOM);
-        }
-    }
-
-    /**
-     * Generates a blank Cells in full Sudoku game board.
-     * @param limit number of blank cells given puzzle should have.
-     * @param iteration used iteration type through Boards cells.
-     */
-    public void generateBlankCells(int limit, Iteration iteration) {
-        this.limit = limit;
-        board.setIterationOrder(iteration);
-        ListIterator<Cell> iterator = board.iterator();
-        board.save();
-
-        while (iterator.hasNext()) {
-            Cell current = iterator.next();
-            current.save();
-
-
-            if (!current.isBlank()) {
-                current.setValue(0);
-            } else {
-                continue;
-            }
-
-            solver.setBoard(board);
-            blankCells = getBlankCells(board);
-            if(isOutOfLimits(limit)) {
-                break;
-            }
-
-            if (hasMoreThanOneSolution(blankCells)) {
-                board.load();
-            } else {
-                current.save();
-            }
-        }
-        board.setIterationOrder(Iteration.LINEAR);
-    }
-
-    /**
-     * Determines when there is too many number of solution for given type of task.
-     * @param limit restraining value.
-     * @return true if there is more or equal number of blank Cells in caparison to demanded fo given difficulty level,
-     */
-    public boolean isOutOfLimits(int limit) {
-        return blankCells.size() >= limit;
-    }
-
-    /**
-     * @param blanks List of blank Cells, which combination with hint numbers, is tested for solution uniqueness.
-     * @return true if given set of values has one solution.
-     */
-    private boolean hasMoreThanOneSolution(List<Cell> blanks) {
-        return solver.solve(blanks, 3) != 1;
-    }
-
-    /**
-     * @param board Sudoku game board.
-     * @return List of blank Cells in given Board.
-     */
-    public static List<Cell> getBlankCells(Board board) {
-        List<Cell> blank = new ArrayList<Cell>();
-        for(Cell cell : board) {
-            if(cell.isBlank()) {
-                blank.add(cell);
-            }
-        }
-        return blank;
-    }
-}
Index: src/main/java/com/intech/mysudoku/tools/Iteration.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.tools;\r\n\r\n/**\r\n * Enum class for types of iterating through cells of given Sudoku board. The different types of iteration are\r\n * used during creation of game boards of varied difficulty.\r\n */\r\n\r\npublic enum Iteration {\r\n    LINEAR, RANDOM, S_LIKE;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/tools/Iteration.java b/src/main/java/com/intech/mysudoku/tools/Iteration.java
--- a/src/main/java/com/intech/mysudoku/tools/Iteration.java	
+++ b/src/main/java/com/intech/mysudoku/tools/Iteration.java	
@@ -1,10 +1,0 @@
-package com.intech.mysudoku.tools;
-
-/**
- * Enum class for types of iterating through cells of given Sudoku board. The different types of iteration are
- * used during creation of game boards of varied difficulty.
- */
-
-public enum Iteration {
-    LINEAR, RANDOM, S_LIKE;
-}
Index: src/main/java/com/intech/mysudoku/tools/Sudoku.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.intech.mysudoku.tools;\r\n\r\n\r\n/* Deprecated */\r\npublic class Sudoku {\r\n\t\r\n\tint[] mat[];\r\n\tint N; // number of columns/rows\r\n\tint SRN; // square root of N\r\n\tint K; // number of missing digits\r\n \r\n    /**\r\n     * Constructor\r\n     * @param N number of columns/rows\r\n     * @param K number of missing digits\r\n     */\r\n    public Sudoku(int N, int K) {\r\n        this.N = N;\r\n        this.K = K;\r\n \r\n        // Compute square root of N\r\n        Double SRNd = Math.sqrt(N);\r\n        SRN = SRNd.intValue();\r\n \r\n        mat = new int[N][N];\r\n    }\r\n \r\n    /**\r\n     * Sudoku Generator\r\n     */\r\n    public void fillValues() {\r\n        // Fill the diagonal of SRN x SRN matrices\r\n        fillDiagonal();\r\n \r\n        // Fill remaining blocks\r\n        fillRemaining(0, SRN);\r\n \r\n        // Remove Randomly K digits to make game\r\n        removeKDigits();\r\n    }\r\n \r\n    /**\r\n     * Fill the diagonal SRN number of SRN x SRN matrices\r\n     */\r\n    void fillDiagonal() {\r\n \r\n        for (int i = 0; i<N; i=i+SRN)\r\n \r\n            // for diagonal box, start coordinates->i==j\r\n            fillBox(i, i);\r\n    }\r\n \r\n    /**\r\n     * Returns false if given 3 x 3 block contains num.\r\n     * @param rowStart\r\n     * @param colStart\r\n     * @param num\r\n     * @return boolean\r\n     */\r\n    boolean unUsedInBox(int rowStart, int colStart, int num) {\r\n        for (int i = 0; i<SRN; i++)\r\n            for (int j = 0; j<SRN; j++)\r\n                if (mat[rowStart+i][colStart+j]==num)\r\n                    return false;\r\n \r\n        return true;\r\n    }\r\n \r\n    /**\r\n     * Fill a 3 x 3 matrix.\r\n     * @param row\r\n     * @param col\r\n     */\r\n    void fillBox(int row,int col) {\r\n        int num;\r\n        for (int i=0; i<SRN; i++)\r\n        {\r\n            for (int j=0; j<SRN; j++)\r\n            {\r\n                do\r\n                {\r\n                    num = randomGenerator(N);\r\n                }\r\n                while (!unUsedInBox(row, col, num));\r\n \r\n                mat[row+i][col+j] = num;\r\n            }\r\n        }\r\n    }\r\n \r\n    /**\r\n     * Random generator\r\n     * @param num\r\n     * @return int\r\n     */\r\n    int randomGenerator(int num) {\r\n        return (int) Math.floor((Math.random()*num+1));\r\n    }\r\n \r\n    /**\r\n     * Check if safe to put in cell\r\n     * @param i\r\n     * @param j\r\n     * @param num\r\n     * @return boolean\r\n     */\r\n    boolean CheckIfSafe(int i,int j,int num) {\r\n        return (unUsedInRow(i, num) &&\r\n                unUsedInCol(j, num) &&\r\n                unUsedInBox(i-i%SRN, j-j%SRN, num));\r\n    }\r\n \r\n    /**\r\n     * check in the row for existence\r\n     * @param i\r\n     * @param num\r\n     * @return boolean\r\n     */\r\n    boolean unUsedInRow(int i,int num) {\r\n        for (int j = 0; j<N; j++)\r\n           if (mat[i][j] == num)\r\n                return false;\r\n        return true;\r\n    }\r\n \r\n    /**\r\n     * check in the row for existence\r\n     * @param j\r\n     * @param num\r\n     * @return boolean\r\n     */\r\n    boolean unUsedInCol(int j,int num) {\r\n        for (int i = 0; i<N; i++)\r\n            if (mat[i][j] == num)\r\n                return false;\r\n        return true;\r\n    }\r\n \r\n    /**\r\n     *  A recursive function to fill remaining\r\n     *  matrix\r\n     * @param i\r\n     * @param j\r\n     * @return boolean\r\n     */\r\n    boolean fillRemaining(int i, int j) {\r\n        //  System.out.println(i+\" \"+j);\r\n        if (j>=N && i<N-1) {\r\n            i = i + 1;\r\n            j = 0;\r\n        }\r\n        if (i>=N && j>=N)\r\n            return true;\r\n \r\n        if (i < SRN) {\r\n            if (j < SRN)\r\n                j = SRN;\r\n        } else if (i < N-SRN) {\r\n            if (j==(int)(i/SRN)*SRN)\r\n                j =  j + SRN;\r\n        } else {\r\n            if (j == N-SRN) {\r\n                i = i + 1;\r\n                j = 0;\r\n                if (i>=N)\r\n                    return true;\r\n            }\r\n        }\r\n \r\n        for (int num = 1; num<=N; num++) {\r\n            if (CheckIfSafe(i, j, num)) {\r\n                mat[i][j] = num;\r\n                if (fillRemaining(i, j+1))\r\n                    return true;\r\n \r\n                mat[i][j] = 0;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n \r\n    /**\r\n     * Remove the K numbers of digits to\r\n     * complete game\r\n     */\r\n    public void removeKDigits() {\r\n        int count = K;\r\n        while (count != 0) {\r\n            int cellId = randomGenerator(N*N)-1;\r\n \r\n            // System.out.println(cellId);\r\n            // extract coordinates i  and j\r\n            int i = (cellId/N);\r\n            int j = cellId%9;\r\n            if (j != 0)\r\n                j = j - 1;\r\n \r\n            // System.out.println(i+\" \"+j);\r\n            if (mat[i][j] != 0) {\r\n                count--;\r\n                mat[i][j] = 0;\r\n            }\r\n        }\r\n    } \r\n \r\n    /**\r\n     * Print sudoku\r\n     */\r\n    public void printSudoku() {\r\n        for (int i = 0; i<N; i++)\r\n        {\r\n            for (int j = 0; j<N; j++)\r\n                System.out.print(mat[i][j] + \" \");\r\n            System.out.println();\r\n        }\r\n        System.out.println();\r\n    }\r\n    \r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/intech/mysudoku/tools/Sudoku.java b/src/main/java/com/intech/mysudoku/tools/Sudoku.java
--- a/src/main/java/com/intech/mysudoku/tools/Sudoku.java	
+++ b/src/main/java/com/intech/mysudoku/tools/Sudoku.java	
@@ -1,220 +1,0 @@
-package com.intech.mysudoku.tools;
-
-
-/* Deprecated */
-public class Sudoku {
-	
-	int[] mat[];
-	int N; // number of columns/rows
-	int SRN; // square root of N
-	int K; // number of missing digits
- 
-    /**
-     * Constructor
-     * @param N number of columns/rows
-     * @param K number of missing digits
-     */
-    public Sudoku(int N, int K) {
-        this.N = N;
-        this.K = K;
- 
-        // Compute square root of N
-        Double SRNd = Math.sqrt(N);
-        SRN = SRNd.intValue();
- 
-        mat = new int[N][N];
-    }
- 
-    /**
-     * Sudoku Generator
-     */
-    public void fillValues() {
-        // Fill the diagonal of SRN x SRN matrices
-        fillDiagonal();
- 
-        // Fill remaining blocks
-        fillRemaining(0, SRN);
- 
-        // Remove Randomly K digits to make game
-        removeKDigits();
-    }
- 
-    /**
-     * Fill the diagonal SRN number of SRN x SRN matrices
-     */
-    void fillDiagonal() {
- 
-        for (int i = 0; i<N; i=i+SRN)
- 
-            // for diagonal box, start coordinates->i==j
-            fillBox(i, i);
-    }
- 
-    /**
-     * Returns false if given 3 x 3 block contains num.
-     * @param rowStart
-     * @param colStart
-     * @param num
-     * @return boolean
-     */
-    boolean unUsedInBox(int rowStart, int colStart, int num) {
-        for (int i = 0; i<SRN; i++)
-            for (int j = 0; j<SRN; j++)
-                if (mat[rowStart+i][colStart+j]==num)
-                    return false;
- 
-        return true;
-    }
- 
-    /**
-     * Fill a 3 x 3 matrix.
-     * @param row
-     * @param col
-     */
-    void fillBox(int row,int col) {
-        int num;
-        for (int i=0; i<SRN; i++)
-        {
-            for (int j=0; j<SRN; j++)
-            {
-                do
-                {
-                    num = randomGenerator(N);
-                }
-                while (!unUsedInBox(row, col, num));
- 
-                mat[row+i][col+j] = num;
-            }
-        }
-    }
- 
-    /**
-     * Random generator
-     * @param num
-     * @return int
-     */
-    int randomGenerator(int num) {
-        return (int) Math.floor((Math.random()*num+1));
-    }
- 
-    /**
-     * Check if safe to put in cell
-     * @param i
-     * @param j
-     * @param num
-     * @return boolean
-     */
-    boolean CheckIfSafe(int i,int j,int num) {
-        return (unUsedInRow(i, num) &&
-                unUsedInCol(j, num) &&
-                unUsedInBox(i-i%SRN, j-j%SRN, num));
-    }
- 
-    /**
-     * check in the row for existence
-     * @param i
-     * @param num
-     * @return boolean
-     */
-    boolean unUsedInRow(int i,int num) {
-        for (int j = 0; j<N; j++)
-           if (mat[i][j] == num)
-                return false;
-        return true;
-    }
- 
-    /**
-     * check in the row for existence
-     * @param j
-     * @param num
-     * @return boolean
-     */
-    boolean unUsedInCol(int j,int num) {
-        for (int i = 0; i<N; i++)
-            if (mat[i][j] == num)
-                return false;
-        return true;
-    }
- 
-    /**
-     *  A recursive function to fill remaining
-     *  matrix
-     * @param i
-     * @param j
-     * @return boolean
-     */
-    boolean fillRemaining(int i, int j) {
-        //  System.out.println(i+" "+j);
-        if (j>=N && i<N-1) {
-            i = i + 1;
-            j = 0;
-        }
-        if (i>=N && j>=N)
-            return true;
- 
-        if (i < SRN) {
-            if (j < SRN)
-                j = SRN;
-        } else if (i < N-SRN) {
-            if (j==(int)(i/SRN)*SRN)
-                j =  j + SRN;
-        } else {
-            if (j == N-SRN) {
-                i = i + 1;
-                j = 0;
-                if (i>=N)
-                    return true;
-            }
-        }
- 
-        for (int num = 1; num<=N; num++) {
-            if (CheckIfSafe(i, j, num)) {
-                mat[i][j] = num;
-                if (fillRemaining(i, j+1))
-                    return true;
- 
-                mat[i][j] = 0;
-            }
-        }
-        return false;
-    }
- 
-    /**
-     * Remove the K numbers of digits to
-     * complete game
-     */
-    public void removeKDigits() {
-        int count = K;
-        while (count != 0) {
-            int cellId = randomGenerator(N*N)-1;
- 
-            // System.out.println(cellId);
-            // extract coordinates i  and j
-            int i = (cellId/N);
-            int j = cellId%9;
-            if (j != 0)
-                j = j - 1;
- 
-            // System.out.println(i+" "+j);
-            if (mat[i][j] != 0) {
-                count--;
-                mat[i][j] = 0;
-            }
-        }
-    } 
- 
-    /**
-     * Print sudoku
-     */
-    public void printSudoku() {
-        for (int i = 0; i<N; i++)
-        {
-            for (int j = 0; j<N; j++)
-                System.out.print(mat[i][j] + " ");
-            System.out.println();
-        }
-        System.out.println();
-    }
-    
-}
-
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"eea2fdd6-9804-4e8d-9912-abd8c90a911a\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/com/intech/mysudoku/App.java\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/com/intech/mysudoku/PrimaryController.java\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/com/intech/mysudoku/SecondaryController.java\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/module-info.java\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/resources/com/intech/mysudoku/primary.fxml\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/resources/com/intech/mysudoku/secondary.fxml\" beforeDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"29FHxV83Jb2nbISODM32KfxDSWF\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"WebServerToolWindowFactoryState\": \"false\",\r\n    \"last_opened_file_path\": \"C:/Users/33650/OneDrive/Documents/INTECH/S3-2/PI/Sudoku\",\r\n    \"project.structure.last.edited\": \"SDKs\",\r\n    \"project.structure.proportion\": \"0.15\",\r\n    \"project.structure.side.proportion\": \"0.2\"\r\n  }\r\n}]]></component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"eea2fdd6-9804-4e8d-9912-abd8c90a911a\" name=\"Changes\" comment=\"\" />\r\n      <created>1652702161947</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1652702161947</updated>\r\n      <workItem from=\"1652702164834\" duration=\"4450000\" />\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n</project>
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	
+++ b/.idea/workspace.xml	
@@ -5,12 +5,22 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="eea2fdd6-9804-4e8d-9912-abd8c90a911a" name="Changes" comment="">
-      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/App.java" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/PrimaryController.java" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/SecondaryController.java" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/module-info.java" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/resources/com/intech/mysudoku/primary.fxml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/resources/com/intech/mysudoku/secondary.fxml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/pom.xml" beforeDir="false" afterPath="$PROJECT_DIR$/pom.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/application/MySudokuApp.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/application/MySudokuApp.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/controllers/GameScreenController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/controllers/GameScreenController.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/controllers/SettingsScreenController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/controllers/SettingsScreenController.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/controllers/TitleScreenController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/controllers/TitleScreenController.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/model/SudokuGenerator.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/model/SudokuGenerator.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Board.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Board.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Cell.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Cell.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Creator.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Creator.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Iteration.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Iteration.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Level.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Level.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Solver.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Solver.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Sudoku.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/intech/mysudoku/tools/Sudoku.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/resources/views/titleScreen.fxml" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/resources/views/titleScreen.fxml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/resources/views/views.txt" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/resources/com/intech/mysudoku/view/views.txt" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -41,12 +51,74 @@
     "RunOnceActivity.OpenProjectViewOnStart": "true",
     "RunOnceActivity.ShowReadmeOnStart": "true",
     "WebServerToolWindowFactoryState": "false",
-    "last_opened_file_path": "C:/Users/33650/OneDrive/Documents/INTECH/S3-2/PI/Sudoku",
+    "last_opened_file_path": "C:/Users/33650/OneDrive/Documents/INTECH/S3/PI/kaizoku-arena/kaizoku-arena",
     "project.structure.last.edited": "SDKs",
     "project.structure.proportion": "0.15",
     "project.structure.side.proportion": "0.2"
   }
 }]]></component>
+  <component name="RecentsManager">
+    <key name="MoveFile.RECENT_KEYS">
+      <recent name="C:\Users\33650\OneDrive\Documents\INTECH\S3-2\PI\mysudoku\src\main\resources\views" />
+      <recent name="C:\Users\33650\OneDrive\Documents\INTECH\S3-2\PI\mysudoku\src\main\resources\com\intech\mysudoku" />
+    </key>
+  </component>
+  <component name="RunManager" selected="Maven.MySudoku [javafx:run]">
+    <configuration name="MySudoku [javafx:run]" type="MavenRunConfiguration" factoryName="Maven">
+      <MavenSettings>
+        <option name="myGeneralSettings" />
+        <option name="myRunnerSettings" />
+        <option name="myRunnerParameters">
+          <MavenRunnerParameters>
+            <option name="profiles">
+              <set />
+            </option>
+            <option name="goals">
+              <list>
+                <option value="javafx:run" />
+              </list>
+            </option>
+            <option name="pomFileName" value="pom.xml" />
+            <option name="profilesMap">
+              <map />
+            </option>
+            <option name="resolveToWorkspace" value="false" />
+            <option name="workingDirPath" value="$PROJECT_DIR$" />
+          </MavenRunnerParameters>
+        </option>
+      </MavenSettings>
+      <method v="2" />
+    </configuration>
+    <configuration name="mysudoku [javafx:run]" type="MavenRunConfiguration" factoryName="Maven" nameIsGenerated="true">
+      <MavenSettings>
+        <option name="myGeneralSettings" />
+        <option name="myRunnerSettings" />
+        <option name="myRunnerParameters">
+          <MavenRunnerParameters>
+            <option name="profiles">
+              <set />
+            </option>
+            <option name="goals">
+              <list>
+                <option value="javafx:run" />
+              </list>
+            </option>
+            <option name="pomFileName" />
+            <option name="profilesMap">
+              <map />
+            </option>
+            <option name="resolveToWorkspace" value="false" />
+            <option name="workingDirPath" value="$PROJECT_DIR$" />
+          </MavenRunnerParameters>
+        </option>
+      </MavenSettings>
+      <method v="2" />
+    </configuration>
+    <list>
+      <item itemvalue="Maven.MySudoku [javafx:run]" />
+      <item itemvalue="Maven.mysudoku [javafx:run]" />
+    </list>
+  </component>
   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="TaskManager">
     <task active="true" id="Default" summary="Default task">
@@ -55,7 +127,7 @@
       <option name="number" value="Default" />
       <option name="presentableId" value="Default" />
       <updated>1652702161947</updated>
-      <workItem from="1652702164834" duration="4450000" />
+      <workItem from="1652702164834" duration="7438000" />
     </task>
     <servers />
   </component>
diff --git a/src/main/resources/views/views.txt b/src/main/resources/views/views.txt
deleted file mode 100644
